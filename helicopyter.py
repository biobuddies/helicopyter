"""Generate JSON which Terraform can use from Python."""

from collections.abc import Callable, Iterable
from functools import partial
from importlib import import_module
from json import dump
from pathlib import Path

from cdktf import (
    App,
    TerraformElement,
    TerraformLocal,
    TerraformOutput,
    TerraformStack,
    TerraformVariable,
)
from constructs import Construct, Node
from tap import Tap


class HeliStack(TerraformStack):
    def __init__(self, code: str) -> None:
        self.code = code
        # Something is automatically creating outdir, which is cdktf.out by default
        super().__init__(App(outdir='.'), code)
        self.Local = partial(TerraformLocal, Construct(self, 'local'))
        self.Output = partial(TerraformOutput, Construct(self, 'output'))
        self.Variable = partial(TerraformVariable, Construct(self, 'variable'))

    def _allocate_logical_id(self, element: Node | TerraformElement) -> str:
        if isinstance(element, Node):
            # Mostly for mypy. Patches to support AWS CDK welcome.
            raise TypeError('AWS CDK unsupported; please use CDKTF')
        return element.node.id

    def load(self, label: str) -> Callable[..., type[TerraformElement]]:
        """
        Return a class given a substring of the module/package name.

        Example usage:
        stack.load('null_resource')
        """
        provider, _, snake_case_element = label.partition('_')
        print(f'Loading {snake_case_element} from {provider}')
        module = import_module(f'cdktf_cdktf_provider_{provider}.{snake_case_element}')
        if snake_case_element == 'provider':
            camel_case_element = f'{provider.title()}Provider'
        else:
            camel_case_element = ''.join(part.title() for part in snake_case_element.split('_'))
        element_class = getattr(module, camel_case_element)
        if issubclass(element_class, TerraformElement):
            return partial(element_class, Construct(self, module.__name__))
        raise Exception(f'{camel_case_element} is not a TerraformElement')

    def push(self, element: TerraformElement) -> TerraformElement:
        """No-op for easier migration."""
        return element


# ruff: noqa: T201
def multisynth(codes: Iterable[str]) -> None:
    if not codes:
        print('No code specified. Doing nothing.')
        return

    if 'all' in codes:
        codes = {
            file.parent.parent.name
            for file in (Path(__file__).parent / 'deploys').glob('**/terraform/main.py')
        }

    for path_or_code in codes:
        path_to_check = Path(path_or_code)
        if (
            path_to_check.exists()
            and path_to_check.name == 'main.py'
            and path_to_check.parent.name == 'terraform'
        ):
            code = path_to_check.parent.parent.name
        else:
            code = path_or_code
        relative_path = f'deploys/{code}/terraform/main.tf.json'
        print(f'Generating {relative_path}')
        module = import_module(f'deploys.{code}.terraform.main')
        stack = HeliStack(code)
        module.synth(stack)
        dictionary = stack.to_terraform()
        dictionary['//']['AUTOGENERATED'] = 'by helicopyter'
        with (Path(__file__).parent / relative_path).open('w') as output:
            dump(dictionary, output, indent=4, sort_keys=True)
            output.write('\n')


class Parameters(Tap):
    codes: list[str]

    def configure(self) -> None:  # noqa: D102
        self.add_argument('codes')


if __name__ == '__main__':
    args = Parameters().parse_args()
    multisynth(args.codes)
